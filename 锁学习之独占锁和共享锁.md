# 锁学习之独占锁和共享锁

在并发包下，Lock接口定义了锁的一个接口定义。而AQS则提供了一套模板方法，其余的锁实现只需要使用静态内部类继承其并重写需要的方法即可，然后调用AQS，其实就是调用自己写的实现方法。

## 独占锁

故名思意，独占锁就是一个时刻只能允许一个线程获取到该锁，只有等当前线程释放锁后才能获取到。

**加锁过程**：线程先去获取当前状态，如果发现已经被获取，则构建节点，然后放入阻塞队列中，然后检查上一个节点是否为头节点，为头节点则会进行尝试获取锁，若成功获取锁，则将后面一个节点进行唤醒。

在构造节点中，使用CAS的方法确保能够准确的将当前节点加入队列尾，从而保证了队列节点不丢失，节点顺序也不乱。

当在队列中则一直进行死循环来检查自身上一个节点是否是头节点，因为唤醒是按照先进先出来的，当上一个节点为头节点时，则表示当前节点可以尝试获取同步锁，若获得，则将当前置为头节点，并且尝试唤醒后继节点。

**释放过程**：应为是独占锁，只能有一个线程获取，所以释放锁时直接将锁的状态为进行更新为未有锁占据即可。

## 共享锁‘

股珉肆意，共享锁允许多个线程同时读取该锁。如读锁，允许多个线程在同时对该内容进行读取。

**加锁过程**：同样也是实现一个静态内部类来实现AQS并重写一些方法。设置可以共享的线程数，每当一条线程获取到该锁，则将技术减1，当释放锁时则进行加1，每当一天线程进来试图获取该锁的时候，会先获取当前的技术，如果大于0，则表示可以获取锁进行共享，；若小于0，则表示不能获取该锁，则进行自旋同步等待。

**释放过程**：因为是几条线程同时获取该锁，要保证同步性，所以在释放锁时需要原子性的更新技术状态。





























