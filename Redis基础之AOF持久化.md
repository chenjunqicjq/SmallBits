# Redis基础之AOF持久化

## AOF持久化的实现

**命令追加**：当服务器执行完一条命令之后会将该条命令转换成符合Redis格式的符文添加到AOF缓存区。

**文件写入和同步**：服务器在执行一个时间结束之前，会调用函数来判断是否将缓存中的数据写入并同步到AOF文件中。根据判断属性的不同有不同的方式：当属性为awlays时，会将数据都写入并且同步到AOF文件中，当出现问题时只会对视一条命令；当属性为everysec时，只会将数据写入文件，然后判断当前时间距离上一次的同步是否有一秒，有则同步到AOF文件中，当出现问题是会丢失1秒没的命令；当属性为no时，仅仅只是加入文件，何时同步入文件有系统控制，当出问题时会对视从上一次同步到现在的所有命令。

## AOF的载入与数据还原

因为AOF文件中保存了所有的操作命令，当需要还原数据库时就可以将AOF文件中保存的数据取出，还原为命令，然后生成一个伪客户端（没有网络链接）。

## AOF的重写

Redis使用AOF持久化时将操作命令保存在AOF文件中，但当操作命令很多时，或者对一些数据重复加入，删除，数据库的数据还是几乎不变，那么在AOF文件会变得非常巨大，当将AOF文件读入时可能会造成读取的线程阻塞，导致数据库停止使用。而Redis则提供了重写功能，可以大大的减小AOF文件的体积，并且并不会改变数据可里面的数据。

**实现**：重写并不是依靠执行AOF文件中的命令来实现的，而是直接去读取当前数据库里面的数据，记录当前的键值对的数据，然后将当前的状态保存在AOF文件中。

**AOF后台重写**：当执行重写时有很多写操作，调用的线程会被阻塞，而且Redis是使用单线程来处理命令请求的，可能会导致很长一段时间内不能处理命令请求。所以引入了后台重写，创建一个子进程来执行重写功能而父进程同时依然可以处理命令请求。使用进程的好处：1.当子进程在重写时父进程可以依然执行命令请求；2.子进程是父进程的数据副本，可以保证在避免使用锁的情况下保证数据的安全性。

当然，这里又有一个问题，当子进程在执行重写操作时，父进程在同时处理命令请求，那么当子进程完了后依然不能保证数据一致性。

解决方法是当子进程重写时，有命令请求进来，则父进程执行，同时将命令同时发送给AOF缓存区和子进程，当子进程执行完后再根据缓存区中的命令更新AOF文件，然后用新的AOF替代老的AOF文件。































