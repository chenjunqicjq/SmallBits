# 集合

集合主要分为Collection和Map两个方向。而Collection又主要有List和Set两方面。实现List接口的常用的有ArrayList,LinedList,Vector;而实现Set接口的常用的有HashSet,TreeSet,LinkedHashSet;而实现Map接口的常用的HashMap,Hashtable,LinkedHashMap,TreeMap.

##List

###ArrayList

ArrayList底层是基于动态数组实现的，作为一个数组，可以对元素实现快速随机访问，这是一个优势，动态数组可以实现动态扩容，可以使用更方便，不必再去手动扩容。当集合进行空构造创建时，会默认分配10个空间，而当空间不够时能扣触发自动扩容机制，每次都会将空间扩大为以前的1.5倍，扩容后，再将元素复制过去。

同时，ArrayList允许存储null值，并且支持根据下标值或内容来查找内容。

支持快速失败机制，可以对多线程对集合的结构进行改变时进行异常抛出。

###LinkedList

LinkeedList是基于链表结构实现的，当添加一个元素时就为链表添加一个节点，同时元素允许为null值。当查找元素时并不支持快速随机访问，查找一个元素需要对链表进行遍历从而查找到所需的元素，查找链表的实现为二分查找。同样具有快速失败机制，可以在多线程时快速检查到数据被修改。

### Vector

Vector在功能上和ArrayList很类似，都能实现类似的数组增删改查，但ArrayList在多线程下却是不安全的，而Vector在多线程环境下却是安全的，其的很多方法都使用Synchronized关键字进行了修饰，可以保证在调用其方法时同时只有一个线程可以进行操作。但是每个方法都用Synchronized修饰，会大大的消耗其性能。

##ArrayList和LinkedList区别

首先是底层的实现不同，ArrayList底层是一个动态数组，而LinkedList的底层则是一个链表。

其次则是应为各自底层结构带来的差别：ArrayList执行查找和修改操作时会比较快，只需要O(1)，但是在进行增加和删除元素的操作上则是比较慢，每次执行这两个操作时都会导致数组结构改变；而LinkedList则是在查找和修改操作复杂度会大些，需要进行遍历链表查找元素，而删除和加入新元素则比较快，只需要挂上即可。

## Set

###HashSet

实现Set接口的集合都不允许元素重复，每个元素只能存在一个。并且元素的存储也不是有序的。因为其底层是一个HashMap，每个元素就是一个HashMap的键，而值则是一个统一的Object对象，就是对HashMap的一种使用，存入元素时会Hash进随机一个槽，所以顺序不是有序的，当然也值允许有一个null值。

### TreeSet

TeeeSet是一个可排序的不重复的集合，集合这种不允许重复元素存在，同时元素也是有序的，使用HashMap的Entry来存放每个元素，使用红黑树来构建排序结构，其中排序的规则用户若果没有规定则使用默认的自然排序，如果用户需要自己定义排序规则，则必须元素实现Comparable接口，实现ComparableTo方法，从而来定义排序规则。

### 为什么eauals()方法和hashCode()方法必须保持一致

equals()方法中默认的实现是使用==来作为两个元素比较的，而==对于对象元素是比较其内存地址的，hashCode()方法默认的实现则是第元素计算的内存地址。如果对equals()方法改变，但是没有重写hashCode()方法，则可能根据equals()判断是相等的，但是最后判断的还是两个元素的内存地址，所以还是不相等。

## Map

### HashMap

HashMap是以键值对来存储元素的集合，每个节点都是一个键值对。底层通过i数组加链表加红黑树的结构来实现，充分用了数组查找快速和链表插入快速的特点。

HashMap在空构造初始化时会默认创建16个空间，如果传入的是一个集合，则初始化的空间为这个集合长度的比他大的第一个2的次放的数。如传入的集合长度为11，则初始化长度为16（二的次方里比11大的第一个数）。

在进行添加一个元素时，会先取其键的hashCode，然后将哈希值h右移16位，再与原来的h做异或^运算——这一步是高位运算。设想一下，如果没有高位运算，那么hash值将是一个int型的32位数。而从2的-31次幂到2的31次幂之间，有将近几十亿的空间，如果我们的HashMap的table有这么长，内存早就爆了。所以这个散列值不能直接用来最终的取模运算，而需要先加入高位运算，将高16位和低16位的信息"融合"到一起，也称为"扰动函数"。这样才能保证hash值所有位的数值特征都保存下来而没有遗漏，从而使映射结果尽可能的松散 ，然后再和数组的长度进行取模操作，最后得到在数组中的下标，然后检查该位置是否有元素，没有则直接放入；有的话则遍历链表，如果有相同的，则返回，没有则在链表结尾挂上。

当数组中槽的空间达到了阈值，则会触发空间扩容。先使用过一个新数组将原数组元素进行保存，然后将数组扩大为原来的2倍，最后再将元素进行哈希放入新的数组中。因为数组长度变长，需要将原来的一个槽中的元素分发到两个槽中，但两个槽中有联系，新的槽为旧的槽的下表加数组原长度，使用元素的hash值与数组旧的长度进行相与操作，为0则放入原槽，为1则放入新槽。

### LinkedHashMap

LinkedHashMap继承了HashMap，但是在HashMap基础上加了一个双向链表，根据元素的插入顺序将其连接起来，可以实现顺序取出元素，弥补了HashMap中元素无顺序的问题。但是维持了一个双向链表，则性能开销上相对来说要大一些。





































