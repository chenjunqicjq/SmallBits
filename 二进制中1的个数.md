# 题目

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示 

# 思路

看了网友的思路发现好多巧妙的思路，大体都是从右往左按位判断是否是1.

**第一种思路**

```java
public class Solution {
    public int NumberOf1(int n) {
        int sum=0;
        while(n!=0){
            sum+=n&1;//逐个判断低位是否为1；
            n=n>>>1;//无符号右移，例如从11101变成1110
        }
        return sum;
    }
}
```

从右往左每位与1相与，当此位为1时计数器加1，然后该数无符号右移，若为右移，当数字为负数时，右移则高位会补充1会导致死循环。使用无符号位移则可以避免这种情况。

**第二种思路**

```java
public class Solution {
    public int NumberOf1(int n) {
        int sum=0;
        while(n!=0){
            sum++;//逐个判断低位是否为1；
            n=n&(n-1);//无符号右移，例如从11101变成1110
        }
        return sum;
    }
}
```

本质思想依然是从右往左找到为1的位，但是此方法巧妙在并不是每次右移1位，而是每次右移一次出现的1位。例如：十进制9=1001，则只需两次循环即可。

过程如下 

   n=1001   

n-1=1000    &

​    n=1000

 n-1=0111    &

​      n=0000

退出循环

【思路】：当一个数减1，则其二进制表示中的**最右的1**变0，从该位往后则变1（都为0），则n与n-1相与，则从最右的1开始的低位都不相同，全为0，最右的1的高位都相同则不变。每比较一次，则消去一个二进制中的1。

n=101**1**00

n-1=101**0**11  &

n=101**0**00

























