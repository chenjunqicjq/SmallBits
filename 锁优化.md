# 锁优化

Java中为了让多线程更好的共享数据，减少相互间的竞争，做了很多优化，如自旋锁及自适应自选，锁消除，偏向锁，轻量级锁。

## 自旋锁及自适应自旋

以前当一个线程获取锁失败后会进行挂起，当获取锁的线程释放锁后会将其唤醒，再重新争夺锁。其中的挂起和唤醒需要切换到核心态去操作，太过于浪费。而且很多时候对共享数据的处理时间很短，甚至比线程挂起和唤醒的时间还短，这样相当不划算。所以引入了自旋锁。当线程来尝试获取锁的时候发现锁已经被获取，不会立刻进行挂起，而是会进行一直自旋来进行等待，直到其他线程释放了该锁或者时间过长而进入挂起状态。

当然，很多时候这可以在很短时间内获得锁，但有时候上一个线程一直获取锁而不释放，这回导致一直自旋，而在自旋时任然还在占用CPU资源，从而导致CPU资源的浪费。所以引入了自适应自旋，可以默认自旋多少次后还没有获取锁就进入挂起状态。而自适应会根据上一次获取该锁的成功与否来进行判断，若果上一次成功获取到锁，那么会认为这一次也可以成功获取到，所以自旋次数会额外的增加；而如果上次失败，则认为该锁不容易获得，则会减少自旋次数。

## 锁消除

虚拟机在编译时会将认为不必要的同步进行消除处理，从而提高处理速度。如在一个字符串的拼接中，其中字符串的拼接操作底层是使用StringBuilder来进行append(),而其中的append()方法中则使用了同步块，但是在编译时会对其进行检查，发现锁的对象都是该对象，锁的范围就是拼接这么多，不会被其他线程获取，所以就将这部分的锁给消除了。

## 锁粗化

锁粗化和锁优化有点相反的意思。平常使用锁的时候都是尽量将锁的范围竟可能的小，到有些时候对一个频繁操作的对象不断的枷锁释放锁显得实在麻烦和低效，这是会对锁进行粗化，将锁的范围扩大，使获取锁和释放锁的操作减少。

## 偏向锁

故名思意，就是会对某一条线程进行偏向。当一条线程尝试获取锁时发现并没有线程获取锁，并且对象头中的偏向锁并未开启，则获得锁，并且将自己的线程id写入对象头中，而下一次如果需要再此获取此锁时，只需验证对象头里保存的线程id是否于当前相等，若相等则直接进入线程。

**偏向锁的撤销**：当已经有一条线程获取了偏向锁时，另一条线程进来尝试获取锁，对比线程id发现不是自己，会尝试进行写入自己的线程id，若果失败，则会触发偏向锁的撤销。此时原本获得的线程停止执行，将对象头中的线程id删除，退出偏向锁。



























