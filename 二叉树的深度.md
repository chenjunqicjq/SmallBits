#题目
---
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

#思路
---
第一反应用递归写，遍历，对比左右子树的高度，比较两颗子树的高度即可
**代码如下**
`public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root==null){
             return 0;
        }
        int leftnum=TreeDepth(root.left);
        int  rightnum=TreeDepth(root.right);
        return leftnum>rightnum?leftnum+1:rightnum+1;
    }
}`
第二想法就是用按层遍历来进行树的深度的计算，但是在判断每层完的条件这里不是想很清楚，直到看了其他人的答案，真的佩服，count,nextcount的运用很巧妙，将队列的头节点取出的同时将其存在的子节点加入到队列中，同时count记录当层的长度，当count的长度与nextcount的长度相等时表示本层遍历完，则更新下一层的长度nextcount等于当前队列的长度，因为此时上一层的节点已经全取出了，再将本层的长度count更新置零，树的深度加一。
**代码如下**
`public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root==null ){
            return 0;
        }
        Queue<TreeNode>list=new LinkedList<TreeNode>();
        int count,nextcount,deep;
        list.add(root);
        count=0;
        nextcount=1;
        deep=1;
        while(!list.isEmpty()){
            TreeNode k=list.poll();
            if(k.left!=null){
                list.add(k.left);
            }
            if(k.right!=null){
                list.add(k.right);
            }
            if(count==nextcount){
                nextcount=list.size();
                count=0;
                deep++;
            }
            count++;
        }
        return deep;
    }
}`