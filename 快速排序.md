# 快速排序

## 单轴快排

### 两端交换扫描

该实现是取一个中心元素，然后两个指针分别在数组的头和尾，当i遍历到比中心元素大的元素，J遍历到比中心元素小的元素，则两个位置进行交换，然后依次向中间靠近，当j<=i时，则将中心元素放到j所在的位置。

**代码如下**：

```java
 public void quickSort(int [] nums,int start,int end){
        if(start<end){
            int pivot=nums[start];
            int i=start+1,j=end;
            while(i<=j){
                while(i<=j&&nums[i]<=pivot){
                    i++;
                }
                while(i<=j&&nums[j]>=pivot){
                    j--;
                }
                if(i<=j){
                    swap(nums,i,j);
                }

            }
            swap(nums,start,j);
            quickSort(nums,start,j-1);
            quickSort(nums,j+1,end);
        }
    }
    public void swap(int []nums,int i,int j){
        int t=nums[i];
        nums[i]=nums[j];
        nums[j]=t;
    }
```



### 挖坑式快排

类似与两端交换，先将中心元素保存起来，也是向中间靠拢，当i发现比中心元素大的元素，直接将j所在位置复制为i所在的元素，此时相当于将i位置元素已经交换过去，则现在i位置的元素就相当于多余，就是一个待填的坑，此时开始J的扫描，找到小于中心元素，则一样的操作，将j所在元素赋值到i所在的坑里，则j现在就是一个坑。当i,j相遇，则表示当前位置是个待填的坑，则将中心元素放入。

**注意**：当扫描时需要首先从尾开始扫描，因为当从首开始扫描，找到大于中心元素的值后，直接覆盖尾，则末尾元素就消失；而从尾开始，即使头元素被覆盖，但是中心元素保留了该元素。

**代码如下**：

```java
public void quickSort(int []nums,int start,int end){
       if(start<end){
           int i=start,j=end;
           int pivot=nums[start];
           while(i<j){
               while(i<j&&nums[j]>=pivot){
                   j--;
               }
               nums[i]=nums[j];

               while(i<j&&nums[i]<=pivot){
                   i++;
               }
               nums[j]=nums[i];

           }
           nums[j]=pivot;
           quickSort(nums,start,j-1);
           quickSort(nums,j+1,end);


       }
```



### 单向扫描划分法

单项扫描，则是只从一个方向进行扫描，i，j同时从头扫描到尾，最后出现呢这个情况：start+1--i为小于中心元素，i+1-j为大于中心元素，最后将中心元素和i位置交换。

j往前扫描，当发现小于中心元素，则i++,然后i,j位置交换，j++（因为i在j后面，表示j已经扫描过，不必再重复，所以j直接++）；当发现大于中心元素，则j直接++即可。

**代码如下**：

```java
   public void quickSort(int []nums ,int start,int end){
       if(start<end){
           int i=start,j=start+1;
           int pivot=nums[start];
           while(j<=end){
               if(nums[j]<=pivot){
                   i++;
                   swap(nums,i,j);
                   j++;
               }else if(nums[j]>=pivot){
                   j++;
               }
           }
           swap(nums,start,i);
           quickSort(nums,start,i-1);
           quickSort(nums,i+1,end);
       }
   }
```



### 三分单向扫描

此方法和单项扫描类似，为了解决当有大量和中心元素相等的元素使排序效率十分低下，则将其分为三份，小于中心元素，等于中心元素，大于中心元素。当下次递归处理的时候就不必处理等于中心元素这一块。

使用i,j,k来表示,i,j分别在数组的头和尾，k则是遍历岗哨，当k找到比中心元素小的，则i++然后与k交换位置，k++（交换过来的元素已经遍历过且等于中心元素）；当等于中心元素时则直接k++；当大于中心元素时和j进行交换，j++(k不加1，因为交换过来的元素并没有扫描过)。当k>j时结束，最后则为0-i为小于中心元素，i+1--j-1为等于中心元素，j--尾为大于中心元素。

**代码如下**：

```java
public void quickSort(int []nums,int start,int end){
       if(start<end){
           int pivot=nums[start];
           int i=start,j=end,k=start+1;
           while(k<=j){
               if(nums[k]<pivot){
                   swap(nums,i,k);
                   i++;
                   k++;
               }else if(nums[k]==pivot){
                   k++;
               }else if(nums[k]>pivot){
                   swap(nums,k,j);
                   j--;
               }
           }
           quickSort(nums,start,i-1);
           quickSort(nums,j+1,end);
       }
   }
```



## 双轴快排

双轴的思想和上面的三分单项扫描很类似，只是中心元素变为了两个即privot1,privot2，然后就将数组分为了三部分：小于privot1,小于privot2但是大于privot1，大于privot2。

一般选区开头和结尾作为两个中心元素。如果开头大于结尾，则需交换下位置。则将上面中等于中心元素的地方换成小于privot2大于privot1就行，最后需要进行两次交换，将两个中心元素交换到相应位置。privot1与i交换（就是和小于privot1的最后一个元素），二privot2与j交换（大于privot2的第一个元素）。

**代码如下**：

```java 
public void quickSort(int []nums,int start,int end){
      if(start<end){
          if(nums[start]>end){
              swap(nums,start,end);
          }
          int pivot1=nums[start],pivot2=nums[end];
          int i=start,j=end,k=start+1;
         OUT_LOOP :while(k<j){
              if(nums[k]<pivot1){
                  i++;
                  swap(nums,i,k);
                  k++;
              }else if(pivot1<nums[k]&&nums[k]<=pivot2){
                  k++;
              }else if(nums[k]>pivot2){
                 //需要判断nums[j]的大小
                  //找到小于pivot2的元素，如果大于pivot2，则省的交换
                  while(nums[--j]>pivot2){
                      if(j<=k){
                          break OUT_LOOP;
                      }
                  }
                  //若果小于pivot1，则需要先与k交换，然后再与i交换
                  if(nums[j]<pivot1){
                      swap(nums,j,k);
                      swap(nums,++i,k);
                      k++;
                  }else {
                      //如果处于两个中心元素之间，直接交换就行
                      swap(nums,j,k);
                      k++;
                  }
              }
          }
          swap(nums,start,i);
          swap(nums,j,end);
          quickSort(nums,start,i-1);
          quickSort(nums,i+1,j-1);
          quickSort(nums,j+1,end);
      }
  }
```























































